"functionCode": "// Agent JSON Parser & Validator - Nova-ForgeMaster\nconst input = $input.first().json;\nconst { context, brief_analysis, llm_recommendation } = $json;\n\nlet agentDefinition, llmResponse;\n\ntry {\n  // Parse selon le LLM utilis√©\n  if (llm_recommendation.recommended_llm === 'claude-3-5-sonnet') {\n    llmResponse = input.content || input.text;\n  } else if (llm_recommendation.recommended_llm === 'gpt-4-turbo') {\n    llmResponse = input.choices?.[0]?.message?.content || input.response;\n  } else if (llm_recommendation.recommended_llm === 'deepseek-coder') {\n    llmResponse = input.choices?.[0]?.message?.content || input.response;\n  } else if (llm_recommendation.recommended_llm === 'ollama-llama3.1') {\n    llmResponse = input.message?.content || input.response;\n  }\n\n  // Extraction du JSON\n  const jsonMatch = llmResponse.match(/\\{[\\s\\S]*\\}/);\n  if (jsonMatch) {\n    agentDefinition = JSON.parse(jsonMatch[0]);\n  } else {\n    throw new Error('No valid JSON found in LLM response');\n  }\n\n} catch (parseError) {\n  console.error('Agent parsing error:', parseError);\n  \n  // G√©n√©ration d'un agent de fallback intelligent\n  agentDefinition = generateFallbackAgent(brief_analysis, context);\n  agentDefinition.fallback_generated = true;\n  agentDefinition.original_error = parseError.message;\n}\n\n// Fonction de g√©n√©ration d'agent de fallback\nfunction generateFallbackAgent(analysis, context) {\n  const agentName = `${analysis.agent_purpose.primary.replace(/_/g, '-')}-agent`;\n  \n  return {\n    agent_name: agentName,\n    agent_mission: `Agent automatis√© pour ${analysis.agent_purpose.primary}`,\n    version: '1.0',\n    status: 'fallback_generated',\n    thinking_process: `G√©n√©ration de fallback apr√®s erreur de parsing. Bas√© sur analyse: ${analysis.agent_purpose.primary} avec complexit√© ${analysis.workflow_complexity}`,\n    \n    n8n_workflow: {\n      name: `${agentName}-workflow`,\n      description: `Workflow de fallback pour ${analysis.agent_purpose.primary}`,\n      nodes: [\n        {\n          parameters: {\n            __node_name: 'Webhook Trigger',\n            __node_documentation: 'Point d entr√©e principal pour d√©clencher l agent'\n          },\n          name: 'Webhook',\n          type: 'n8n-nodes-base.webhook',\n          position: [240, 300],\n          id: 'webhook-trigger-001'\n        },\n        {\n          parameters: {\n            __node_name: 'Function Processor',\n            __node_documentation: 'Traitement principal de la logique m√©tier',\n            functionCode: `// Agent ${agentName} - Traitement principal\\nconst input = $json;\\nconsole.log('Agent ${agentName} activ√©:', input);\\nreturn { status: 'processed', agent: '${agentName}', data: input };`\n          },\n          name: 'Function',\n          type: 'n8n-nodes-base.function',\n          position: [460, 300],\n          id: 'function-processor-002'\n        },\n        {\n          parameters: {\n            __node_name: 'Response Handler',\n            __node_documentation: 'Formatage et envoi de la r√©ponse finale'\n          },\n          name: 'Respond to Webhook',\n          type: 'n8n-nodes-base.respondToWebhook',\n          position: [680, 300],\n          id: 'response-handler-003'\n        }\n      ],\n      connections: {\n        'Webhook': {\n          main: [[{ node: 'Function', type: 'main', index: 0 }]]\n        },\n        'Function': {\n          main: [[{ node: 'Respond to Webhook', type: 'main', index: 0 }]]\n        }\n      },\n      settings: {\n        executionOrder: 'v1'\n      }\n    },\n    \n    dependencies: [],\n    estimated_performance: {\n      throughput: 'Standard - 100 requests/hour',\n      latency: 'Low - <500ms',\n      reliability: '85% (fallback agent)'\n    }\n  };\n}\n\n// Validation et enrichissement de l'agent\nif (agentDefinition) {\n  // S'assurer que les champs obligatoires sont pr√©sents\n  agentDefinition.agent_name = agentDefinition.agent_name || 'unnamed-agent';\n  agentDefinition.version = agentDefinition.version || '1.0';\n  agentDefinition.status = agentDefinition.status || 'pending_validation';\n  agentDefinition.dependencies = agentDefinition.dependencies || [];\n  \n  // Ajout de m√©tadonn√©es Nova-ForgeMaster\n  agentDefinition.forgemaster_metadata = {\n    created_by: 'Nova-ForgeMaster-v3.1',\n    forge_id: context.forge_id,\n    creation_timestamp: new Date().toISOString(),\n    llm_used: llm_recommendation.recommended_llm,\n    brief_analysis: brief_analysis.agent_purpose,\n    estimated_complexity: brief_analysis.workflow_complexity\n  };\n  \n  // Validation de s√©curit√© constitutionnelle\n  const securityValidation = validateConstitutionalCompliance(agentDefinition, context);\n  agentDefinition.security_validation = securityValidation;\n}\n\n// Validation constitutionnelle\nfunction validateConstitutionalCompliance(agent, context) {\n  const validation = {\n    passed: true,\n    violations: [],\n    warnings: [],\n    score: 100\n  };\n  \n  // V√©rification des outils interdits\n  const workflowStr = JSON.stringify(agent.n8n_workflow || {}).toLowerCase();\n  const forbiddenTools = ['paypal', 'unauthorized_api', 'hardcoded_key'];\n  \n  forbiddenTools.forEach(tool => {\n    if (workflowStr.includes(tool)) {\n      validation.violations.push(`Outil interdit d√©tect√©: ${tool}`);\n      validation.passed = false;\n      validation.score -= 20;\n    }\n  });\n  \n  // V√©rification de la documentation\n  const nodes = agent.n8n_workflow?.nodes || [];\n  const undocumentedNodes = nodes.filter(node => \n    !node.parameters?.__node_documentation\n  );\n  \n  if (undocumentedNodes.length > 0) {\n    validation.warnings.push(`${undocumentedNodes.length} n≈ìuds sans documentation`);\n    validation.score -= 5 * undocumentedNodes.length;\n  }\n  \n  // V√©rification des credentials\n  const hasCredentials = nodes.some(node => node.credentials);\n  if (hasCredentials) {\n    validation.warnings.push('Agent utilise des credentials - v√©rifier la s√©curit√©');\n  }\n  \n  return validation;\n}\n\n// Calcul du score de qualit√© global\nconst qualityScore = {\n  completeness: agentDefinition?.n8n_workflow?.nodes?.length > 0 ? 100 : 0,\n  documentation: agentDefinition?.thinking_process ? 100 : 50,\n  security: agentDefinition?.security_validation?.score || 0,\n  constitutional_compliance: context.constitutional_compliance.validation_passed ? 100 : 0\n};\n\nconst overallQuality = Math.round(\n  (qualityScore.completeness * 0.4 + \n   qualityScore.documentation * 0.2 + \n   qualityScore.security * 0.3 + \n   qualityScore.constitutional_compliance * 0.1)\n);\n\nreturn {\n  ...$json,\n  generated_agent: agentDefinition,\n  quality_assessment: {\n    overall_score: overallQuality,\n    breakdown: qualityScore,\n    ready_for_sandbox: overallQuality >= 70,\n    recommendations: overallQuality < 70 ? ['Am√©liorer la documentation', 'V√©rifier la s√©curit√©'] : []\n  },\n  llm_response_raw: llmResponse,\n  parsing_successful: !agentDefinition?.fallback_generated,\n  next_stage: overallQuality >= 70 ? 'sandbox_deployment' : 'quality_improvement',\n  forgemaster_validation_timestamp: new Date().toISOString()\n};"
      },
      "id": "agent-parser-validator-011",
      "name": "üîç Agent Parser & Validator",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1300, 600]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.quality_assessment.ready_for_sandbox }}",
              "value2": true
            }
          ]
        }
      },
      "id": "sandbox-ready-check-012",
      "name": "üß™ Sandbox Ready Check",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [1520, 600]
    },
    {
      "parameters": {
        "functionCode": "// Sandbox Deployment Engine - Test Environment\nconst { generated_agent, quality_assessment, context } = $json;\n\n// Cr√©ation d'un environnement de test isol√©\nfunction deploySandboxAgent(agent, context) {\n  const sandboxConfig = {\n    sandbox_id: `sandbox_${context.forge_id}`,\n    agent_id: agent.agent_name,\n    deployment_mode: 'isolated_test',\n    test_environment: {\n      n8n_instance: 'sandbox_n8n',\n      resource_limits: {\n        max_executions: 10,\n        timeout: 300000, // 5 minutes\n        memory_limit: '512MB'\n      },\n      monitoring: {\n        logs_enabled: true,\n        metrics_collection: true,\n        performance_tracking: true\n      }\n    }\n  };\n\n  // Pr√©paration du workflow pour le sandbox\n  const sandboxWorkflow = {\n    ...agent.n8n_workflow,\n    name: `SANDBOX_${agent.n8n_workflow.name}`,\n    settings: {\n      ...agent.n8n_workflow.settings,\n      saveDataErrorExecution: 'all',\n      saveDataSuccessExecution: 'all',\n      saveManualExecutions: true\n    }\n  };\n\n  // Ajout de n≈ìuds de monitoring pour le test\n  const monitoringNodes = [\n    {\n      parameters: {\n        __node_name: 'Sandbox Monitor Start',\n        __node_documentation: 'D√©but du monitoring en sandbox',\n        functionCode: `console.log('SANDBOX START:', new Date().toISOString(), '${agent.agent_name}'); return $json;`\n      },\n      name: 'Sandbox Monitor Start',\n      type: 'n8n-nodes-base.function',\n      position: [100, 100],\n      id: 'sandbox-monitor-start'\n    },\n    {\n      parameters: {\n        __node_name: 'Sandbox Monitor End',\n        __node_documentation: 'Fin du monitoring avec m√©triques',\n        functionCode: `console.log('SANDBOX END:', new Date().toISOString(), '${agent.agent_name}', 'SUCCESS'); return { ....$json, sandbox_test: 'completed', agent: '${agent.agent_name}' };`\n      },\n      name: 'Sandbox Monitor End',\n      type: 'n8n-nodes-base.function',\n      position: [900, 300],\n      id: 'sandbox-monitor-end'\n    }\n  ];\n\n  // Int√©gration des n≈ìuds de monitoring\n  sandboxWorkflow.nodes = [\n    monitoringNodes[0],\n    ...sandboxWorkflow.nodes,\n    monitoringNodes[1]\n  ];\n\n  // Ajustement des connexions pour inclure le monitoring\n  const originalConnections = sandboxWorkflow.connections || {};\n  sandboxWorkflow.connections = {\n    'Sandbox Monitor Start': {\n      main: [[{ node: sandboxWorkflow.nodes[1]?.name || 'Webhook', type: 'main', index: 0 }]]\n    },\n    ...originalConnections\n  };\n\n  // Ajout de la connexion vers le monitor final\n  const lastNodeName = sandboxWorkflow.nodes[sandboxWorkflow.nodes.length - 2]?.name;\n  if (lastNodeName && sandboxWorkflow.connections[lastNodeName]) {\n    sandboxWorkflow.connections[lastNodeName].main.push([\n      { node: 'Sandbox Monitor End', type: 'main', index: 0 }\n    ]);\n  }\n\n  return {\n    sandbox_config: sandboxConfig,\n    sandbox_workflow: sandboxWorkflow,\n    test_scenarios: generateTestScenarios(agent),\n    deployment_status: 'ready_for_sandbox'\n  };\n}\n\n// G√©n√©ration de sc√©narios de test\nfunction generateTestScenarios(agent) {\n  const baseScenarios = [\n    {\n      name: 'basic_functionality_test',\n      description: 'Test basique du fonctionnement de l agent',\n      test_data: { test: true, message: 'Sandbox test execution' },\n      expected_result: 'success'\n    },\n    {\n      name: 'error_handling_test',\n      description: 'Test de la gestion d erreurs',\n      test_data: { test: true, trigger_error: true },\n      expected_result: 'handled_error'\n    },\n    {\n      name: 'performance_test',\n      description: 'Test de performance et latence',\n      test_data: { test: true, performance_mode: true },\n      expected_result: 'within_limits'\n    }\n  ];\n\n  // Sc√©narios sp√©cialis√©s selon le type d'agent\n  const agentType = agent.forgemaster_metadata?.brief_analysis?.primary || 'general';\n  \n  if (agentType.includes('lead')) {\n    baseScenarios.push({\n      name: 'lead_processing_test',\n      description: 'Test de traitement des leads',\n      test_data: { name: 'Test Lead', email: 'test@example.com', source: 'sandbox' },\n      expected_result: 'lead_processed'\n    });\n  } else if (agentType.includes('content')) {\n    baseScenarios.push({\n      name: 'content_generation_test',\n      description: 'Test de g√©n√©ration de contenu',\n      test_data: { topic: 'Test Topic', format: 'article' },\n      expected_result: 'content_generated'\n    });\n  }\n\n  return baseScenarios;\n}\n\n// Plan de validation des tests\nfunction createValidationPlan(sandboxDeployment) {\n  return {\n    validation_criteria: {\n      execution_success: 'All test scenarios must complete without fatal errors',\n      response_time: 'Average response time < 5 seconds',\n      error_handling: 'Errors must be caught and logged properly',\n      resource_usage: 'Memory usage < 256MB during execution',\n      security_compliance: 'No unauthorized external calls'\n    },\n    validation_steps: [\n      'Deploy workflow to sandbox n8n instance',\n      'Execute each test scenario sequentially',\n      'Collect execution logs and metrics',\n      'Analyze performance and error patterns',\n      'Generate validation report'\n    ],\n    success_threshold: 80, // 80% des crit√®res doivent passer\n    max_test_duration: 300 // 5 minutes maximum\n  };\n}\n\nconst sandboxDeployment = deploySandboxAgent(generated_agent, context);\nconst validationPlan = createValidationPlan(sandboxDeployment);\n\n// Simulation du d√©ploiement (dans un vrai environnement, ceci ferait des appels API r√©els)\nconst deploymentSimulation = {\n  status: 'deployed_to_sandbox',\n  sandbox_url: `https://sandbox-n8n.nova-digit.com/workflow/${sandboxDeployment.sandbox_config.sandbox_id}`,\n  webhook_test_url: `https://sandbox-n8n.nova-digit.com/webhook/test-${generated_agent.agent_name}`,\n  estimated_test_duration: '5-10 minutes',\n  monitoring_dashboard: `https://sandbox-monitor.nova-digit.com/agent/${generated_agent.agent_name}`\n};\n\nreturn {\n  ...$json,\n  sandbox_deployment: sandboxDeployment,\n  validation_plan: validationPlan,\n  deployment_simulation: deploymentSimulation,\n  sandbox_status: 'active',\n  next_stage: 'validation_execution',\n  sandbox_timestamp: new Date().toISOString(),\n  forgemaster_note: `Agent ${generated_agent.agent_name} d√©ploy√© en sandbox avec ${sandboxDeployment.test_scenarios.length} sc√©narios de test`\n};"
      },
      "id": "sandbox-deployment-engine-013",
      "name": "üß™ Sandbox Deployment Engine", 
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1720, 500]
    },
    {
      "parameters": {
        "functionCode": "// Quality Improvement Engine - Agent Enhancement\nconst { generated_agent, quality_assessment, context } = $json;\n\n// Analyse des probl√®mes de qualit√© et g√©n√©ration d'am√©liorations\nfunction analyzeQualityIssues(agent, assessment) {\n  const issues = [];\n  const improvements = [];\n  \n  // Analyse de la compl√©tude\n  if (assessment.breakdown.completeness < 80) {\n    issues.push({\n      type: 'completeness',\n      severity: 'high',\n      description: 'Workflow incomplet ou n≈ìuds manquants',\n      current_score: assessment.breakdown.completeness\n    });\n    \n    improvements.push({\n      action: 'add_missing_nodes',\n      description: 'Ajouter les n≈ìuds manquants pour compl√©ter le workflow',\n      priority: 1,\n      estimated_impact: '+20 points'\n    });\n  }\n  \n  // Analyse de la documentation\n  if (assessment.breakdown.documentation < 70) {\n    issues.push({\n      type: 'documentation',\n      severity: 'medium',\n      description: 'Documentation insuffisante des n≈ìuds et processus',\n      current_score: assessment.breakdown.documentation\n    });\n    \n    improvements.push({\n      action: 'enhance_documentation',\n      description: 'Ajouter documentation compl√®te √† tous les n≈ìuds',\n      priority: 2,\n      estimated_impact: '+15 points'\n    });\n  }\n  \n  // Analyse de la s√©curit√©\n  if (assessment.breakdown.security < 90) {\n    issues.push({\n      type: 'security',\n      severity: assessment.breakdown.security < 50 ? 'critical' : 'high',\n      description: 'Probl√®mes de s√©curit√© ou non-conformit√© constitutionnelle',\n      current_score: assessment.breakdown.security\n    });\n    \n    improvements.push({\n      action: 'fix_security_issues',\n      description: 'Corriger les violations de s√©curit√© et conformit√©',\n      priority: 1,\n      estimated_impact: '+25 points'\n    });\n  }\n  \n  return { issues, improvements };\n}\n\n// G√©n√©ration d'un agent am√©lior√©\nfunction generateImprovedAgent(originalAgent, improvementPlan) {\n  const improvedAgent = JSON.parse(JSON.stringify(originalAgent)); // Deep copy\n  \n  improvedAgent.version = incrementVersion(originalAgent.version || '1.0');\n  improvedAgent.status = 'improved_version';\n  \n  // Application des am√©liorations\n  improvementPlan.improvements.forEach(improvement => {\n    switch(improvement.action) {\n      case 'add_missing_nodes':\n        addMissingNodes(improvedAgent);\n        break;\n      case 'enhance_documentation':\n        enhanceDocumentation(improvedAgent);\n        break;\n      case 'fix_security_issues':\n        fixSecurityIssues(improvedAgent);\n        break;\n    }\n  });\n  \n  // Ajout des m√©tadonn√©es d'am√©lioration\n  improvedAgent.improvement_history = [\n    {\n      version: originalAgent.version || '1.0',\n      improvements_applied: improvementPlan.improvements.map(i => i.action),\n      timestamp: new Date().toISOString(),\n      quality_gain: improvementPlan.estimated_total_gain\n    }\n  ];\n  \n  return improvedAgent;\n}\n\nfunction incrementVersion(version) {\n  const parts = version.split('.');\n  const minor = parseInt(parts[1] || '0') + 1;\n  return `${parts[0]}.${minor}`;\n}\n\nfunction addMissingNodes(agent) {\n  const workflow = agent.n8n_workflow;\n  if (!workflow || !workflow.nodes) return;\n  \n  // Ajout d'un n≈ìud de validation si manquant\n  const hasValidation = workflow.nodes.some(node => \n    node.name.toLowerCase().includes('validation') || \n    node.type === 'n8n-nodes-base.function'\n  );\n  \n  if (!hasValidation) {\n    const validationNode = {\n      parameters: {\n        __node_name: 'Input Validator',\n        __node_documentation: 'Valide les donn√©es d entr√©e avant traitement',\n        functionCode: 'const input = $json; if (!input || Object.keys(input).length === 0) { throw new Error(\"Invalid input data\"); } return input;'\n      },\n      name: 'Input Validator',\n      type: 'n8n-nodes-base.function',\n      position: [340, 300],\n      id: 'input-validator-improved'\n    };\n    \n    workflow.nodes.splice(1, 0, validationNode);\n  }\n  \n  // Ajout d'un n≈ìud de gestion d'erreurs si manquant\n  const hasErrorHandling = workflow.nodes.some(node => \n    node.name.toLowerCase().includes('error') ||\n    node.type === 'n8n-nodes-base.errorTrigger'\n  );\n  \n  if (!hasErrorHandling) {\n    const errorNode = {\n      parameters: {\n        __node_name: 'Error Handler',\n        __node_documentation: 'G√®re les erreurs et g√©n√®re des logs appropri√©s',\n        functionCode: 'console.error(\"Agent Error:\", $json.error); return { status: \"error\", message: $json.error.message, timestamp: new Date().toISOString() };'\n      },\n      name: 'Error Handler',\n      type: 'n8n-nodes-base.function',\n      position: [500, 400],\n      id: 'error-handler-improved'\n    };\n    \n    workflow.nodes.push(errorNode);\n  }\n}\n\nfunction enhanceDocumentation(agent) {\n  const workflow = agent.n8n_workflow;\n  if (!workflow || !workflow.nodes) return;\n  \n  workflow.nodes.forEach(node => {\n    if (!node.parameters) node.parameters = {};\n    \n    if (!node.parameters.__node_name) {\n      node.parameters.__node_name = node.name || 'Unnamed Node';\n    }\n    \n    if (!node.parameters.__node_documentation) {\n      node.parameters.__node_documentation = `${node.type} - R√¥le: traitement des donn√©es. Entr√©es: donn√©es JSON. Sorties: donn√©es transform√©es. Gestion d'erreurs: propagation standard.`;\n    }\n  });\n  \n  // Am√©lioration de la description du workflow\n  if (!workflow.description) {\n    workflow.description = `Workflow ${agent.agent_name} - Mission: ${agent.agent_mission}. Automatisation optimis√©e avec gestion d'erreurs et validation.`;\n  }\n}\n\nfunction fixSecurityIssues(agent) {\n  const workflow = agent.n8n_workflow;\n  if (!workflow || !workflow.nodes) return;\n  \n  workflow.nodes.forEach(node => {\n    // Suppression des cl√©s hardcod√©es\n    if (node.parameters) {\n      Object.keys(node.parameters).forEach(key => {\n        if (key.toLowerCase().includes('key') || key.toLowerCase().includes('token')) {\n          if (typeof node.parameters[key] === 'string' && node.parameters[key].length > 10) {\n            node.parameters[key] = '{{ $credentials.api_key }}';\n          }\n        }\n      });\n    }\n    \n    // Ajout de credentials s√©curis√©s si n√©cessaire\n    if (node.type.includes('http') && !node.credentials) {\n      node.credentials = {\n        httpHeaderAuth: {\n          id: 'secure-api-credentials',\n          name: 'API Credentials'\n        }\n      };\n    }\n  });\n}\n\nconst qualityAnalysis = analyzeQualityIssues(generated_agent, quality_assessment);\nconst estimatedTotalGain = qualityAnalysis.improvements.reduce((sum, imp) => {\n  const gain = parseInt(imp.estimated_impact.match(/\\d+/)?.[0] || '0');\n  return sum + gain;\n}, 0);\n\nqualityAnalysis.estimated_total_gain = estimatedTotalGain;\n\nconst improvedAgent = generateImprovedAgent(generated_agent, qualityAnalysis);\n\n// Nouveau calcul de qualit√© apr√®s am√©liorations\nconst newQualityScore = Math.min(100, quality_assessment.overall_score + estimatedTotalGain);\n\nreturn {\n  ...$json,\n  quality_analysis: qualityAnalysis,\n  improved_agent: improvedAgent,\n  improvement_summary: {\n    original_score: quality_assessment.overall_score,\n    estimated_new_score: newQualityScore,\n    improvements_count: qualityAnalysis.improvements.length,\n    critical_issues_fixed: qualityAnalysis.issues.filter(i => i.severity === 'critical').length,\n    ready_for_retry: newQualityScore >= 70\n  },\n  next_stage: newQualityScore >= 70 ? 'sandbox_deployment' : 'manual_review_required',\n  improvement_timestamp: new Date().toISOString(),\n  forgemaster_note: `Agent am√©lior√© de ${quality_assessment.overall_score} √† ${newQualityScore} points (+${estimatedTotalGain})`\n};"
      },
      "id": "quality-improvement-engine-014",
      "name": "‚ö° Quality Improvement Engine",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1720, 700]
    },
    {
      "parameters": {
        "functionCode": "// Agent Documentation Generator - Complete Agent Package\nconst { sandbox_deployment, improved_agent, generated_agent, quality_assessment, context } = $json;\n\n// S√©lection de l'agent final (am√©lior√© ou original)\nconst finalAgent = improved_agent || generated_agent;\nconst deploymentInfo = sandbox_deployment || {};\n\n// G√©n√©ration de documentation compl√®te\nfunction generateCompleteDocumentation(agent, deployment, context) {\n  const docs = {\n    readme: generateReadme(agent, deployment),\n    technical_specs: generateTechnicalSpecs(agent),\n    api_documentation: generateAPIDocumentation(agent),\n    deployment_guide: generateDeploymentGuide(agent, deployment),\n    maintenance_guide: generateMaintenanceGuide(agent)\n  };\n  \n  return docs;\n}\n\nfunction generateReadme(agent, deployment) {\n  return `# ${agent.agent_name}\n\n## üéØ Mission\n${agent.agent_mission}\n\n## üìä Informations G√©n√©rales\n- **Version**: ${agent.version}\n- **Statut**: ${agent.status}\n- **Cr√©√© par**: Nova-ForgeMaster v3.1\n- **Date de cr√©ation**: ${agent.forgemaster_metadata?.creation_timestamp || new Date().toISOString()}\n- **LLM utilis√©**: ${agent.forgemaster_metadata?.llm_used || 'Unknown'}\n\n## üèóÔ∏è Architecture\n- **N≈ìuds total**: ${agent.n8n_workflow?.nodes?.length || 0}\n- **Complexit√©**: ${agent.forgemaster_metadata?.estimated_complexity || 'Medium'}\n- **Type d'agent**: ${agent.forgemaster_metadata?.brief_analysis?.primary || 'General'}\n\n## ‚ö° Performance Estim√©e\n${Object.entries(agent.estimated_performance || {}).map(([key, value]) => `- **${key}**: ${value}`).join('\\n')}\n\n## üß™ Tests Sandbox\n${deployment?.sandbox_config ? \n  `- **Sandbox ID**: ${deployment.sandbox_config.sandbox_id}\\n- **Sc√©narios de test**: ${deployment.test_scenarios?.length || 0}\\n- **URL de test**: ${deployment?.deployment_simulation?.webhook_test_url || 'N/A'}` : \n  {
  "name": "Nova-ForgeMaster_Agent_Creator",
  "nodes": [
    {
      "parameters": {
        "options": {}
      },
      "id": "forgemaster-chat-trigger-001",
      "name": "üî® ForgeMaster Chat Interface",
      "type": "@n8n/n8n-nodes-langchain.chatTrigger",
      "typeVersion": 1,
      "position": [200, 400]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "nova-forgemaster-api",
        "responseMode": "responseNode"
      },
      "id": "forgemaster-api-trigger-002",
      "name": "üîó ForgeMaster API Endpoint",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [200, 600]
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            { "field": "hours", "hoursInterval": 6 }
          ]
        }
      },
      "id": "forgemaster-audit-trigger-003",
      "name": "üîç Agent Audit Scheduler",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1,
      "position": [200, 800]
    },
    {
      "parameters": {
        "functionCode": "// Nova-ForgeMaster Request Parser & Constitutional Validator\nconst input = $input.first().json;\nconst triggerSource = $node.name;\n\n// G√©n√©ration d'ID de tra√ßage ForgeMaster\nconst forgeId = `forge_${Date.now()}_${Math.random().toString(36).substr(2, 8)}`;\n\n// D√©tection du type de requ√™te\nlet requestType, payload, context;\n\nif (triggerSource.includes('Chat')) {\n  // Requ√™te de cr√©ation d'agent via chat\n  requestType = 'agent_creation_request';\n  payload = {\n    agent_brief: input.chatInput || input.input || input.message,\n    session_id: input.sessionId || `session_${Date.now()}`,\n    user_context: input.userContext || {},\n    creation_mode: 'interactive'\n  };\n} else if (triggerSource.includes('API')) {\n  // Requ√™te API directe\n  requestType = 'api_agent_request';\n  payload = {\n    agent_brief: input.agent_brief || input.brief,\n    agent_specifications: input.specifications || {},\n    target_tools: input.tools || [],\n    complexity_level: input.complexity || 'auto',\n    creation_mode: 'programmatic'\n  };\n} else if (triggerSource.includes('Audit')) {\n  // Audit automatique des agents existants\n  requestType = 'agent_audit_cycle';\n  payload = {\n    audit_type: 'scheduled_review',\n    scope: 'all_active_agents'\n  };\n}\n\n// Validation constitutionnelle - Protocole Anti-Hallucination\nconst constitutionalRules = {\n  forbidden_tools: ['paypal', 'unauthorized_apis'],\n  approved_tools: ['stripe', 'hubspot', 'google_sheets', 'slack', 'notion'],\n  security_requirements: ['no_hardcoded_keys', 'encrypted_credentials', 'audit_trail'],\n  quality_standards: ['documentation_required', 'error_handling', 'testing_mandatory']\n};\n\n// Validation du brief\nif (requestType !== 'agent_audit_cycle') {\n  if (!payload.agent_brief && !payload.agent_specifications) {\n    throw new Error('Brief ou sp√©cifications d\\'agent manquants');\n  }\n  \n  // D√©tection d'outils non autoris√©s dans le brief\n  const briefText = (payload.agent_brief || '').toLowerCase();\n  const forbiddenFound = constitutionalRules.forbidden_tools.filter(tool => \n    briefText.includes(tool)\n  );\n  \n  if (forbiddenFound.length > 0) {\n    console.warn(`Outils non autoris√©s d√©tect√©s: ${forbiddenFound.join(', ')}`);\n  }\n}\n\n// Contexte enrichi Nova-ForgeMaster\ncontext = {\n  forge_id: forgeId,\n  request_type: requestType,\n  timestamp: new Date().toISOString(),\n  source: triggerSource,\n  priority: payload.priority || 'normal',\n  nova_forgemaster_version: '3.1',\n  constitutional_compliance: {\n    rules_applied: Object.keys(constitutionalRules),\n    validation_passed: forbiddenFound?.length === 0,\n    warnings: forbiddenFound || []\n  }\n};\n\n// Analyse de complexit√© pr√©liminaire\nlet estimatedComplexity = 'low';\nif (payload.agent_brief) {\n  const brief = payload.agent_brief.toLowerCase();\n  const complexityIndicators = {\n    high: ['api multiple', 'int√©gration complexe', 'machine learning', 'analyse avanc√©e'],\n    medium: ['api', 'automation', 'workflow', 'int√©gration'],\n    low: ['simple', 'basique', 'notification']\n  };\n  \n  for (const [level, indicators] of Object.entries(complexityIndicators)) {\n    if (indicators.some(indicator => brief.includes(indicator))) {\n      estimatedComplexity = level;\n      break;\n    }\n  }\n}\n\nreturn {\n  valid: true,\n  context: context,\n  payload: payload,\n  estimated_complexity: estimatedComplexity,\n  forgemaster_routing: {\n    next_stage: requestType === 'agent_audit_cycle' ? 'agent_audit' : 'brief_analysis',\n    llm_power_needed: estimatedComplexity === 'high' ? 'maximum' : 'standard',\n    sandbox_testing: true\n  },\n  metadata: {\n    forgemaster_signature: `Nova-ForgeMaster v3.1 - Request ${forgeId}`,\n    processing_start: Date.now()\n  }\n};"
      },
      "id": "forgemaster-parser-004",
      "name": "üß† ForgeMaster Request Parser",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [420, 600]
    },
    {
      "parameters": {
        "functionCode": "// Brief Analysis Engine - Intelligence strat√©gique\nconst { payload, context, estimated_complexity } = $json;\n\n// Analyse approfondie du brief client\nfunction analyzeBrief(brief, specifications) {\n  const analysis = {\n    agent_purpose: { primary: 'unknown', secondary: [], confidence: 0 },\n    required_integrations: [],\n    workflow_complexity: estimated_complexity,\n    technical_requirements: { apis: [], databases: [], tools: [] },\n    business_impact: { priority: 1, roi_potential: 'medium', urgency: 'normal' },\n    suggested_architecture: { pattern: 'simple', components: [] }\n  };\n\n  if (!brief && !specifications) return analysis;\n\n  const text = (brief || '').toLowerCase();\n  \n  // Analyse d'intention avec patterns NovaDigit\n  const intentionPatterns = {\n    'lead_generation': /prospect|lead|g√©n√©r.*lead|collecte.*contact|acquisition/g,\n    'customer_support': /support|aide|assistance|service.*client|helpdesk/g,\n    'content_creation': /contenu|r√©daction|article|post|publication|content/g,\n    'data_processing': /traitement.*donn√©es|analyse.*data|csv|excel|base.*donn√©es/g,\n    'marketing_automation': /campaign|campagne|email.*marketing|automation.*marketing/g,\n    'sales_automation': /vente|commercial|closing|pipeline|crm/g,\n    'social_media': /social|instagram|facebook|linkedin|twitter|tiktok/g,\n    'financial_management': /facturation|paiement|stripe|invoice|comptabilit√©/g,\n    'project_management': /projet|t√¢che|planning|suivi.*projet|gestion.*projet/g,\n    'analytics_reporting': /rapport|analytics|m√©triques|dashboard|reporting/g\n  };\n\n  let maxMatches = 0;\n  let primaryPurpose = 'general_automation';\n  \n  Object.entries(intentionPatterns).forEach(([purpose, pattern]) => {\n    const matches = (text.match(pattern) || []).length;\n    if (matches > maxMatches) {\n      maxMatches = matches;\n      primaryPurpose = purpose;\n    }\n    if (matches > 0) {\n      analysis.agent_purpose.secondary.push(purpose);\n    }\n  });\n  \n  analysis.agent_purpose.primary = primaryPurpose;\n  analysis.agent_purpose.confidence = Math.min(0.95, maxMatches * 0.3 + 0.4);\n\n  // D√©tection des int√©grations requises\n  const integrationPatterns = {\n    'stripe': /stripe|paiement|payment|facturation/g,\n    'hubspot': /hubspot|crm|contact.*management/g,\n    'google_sheets': /google.*sheet|spreadsheet|feuille.*calcul/g,\n    'slack': /slack|notification.*√©quipe|alert.*team/g,\n    'notion': /notion|base.*connaissance|documentation/g,\n    'mailchimp': /mailchimp|email.*marketing|newsletter/g,\n    'google_ads': /google.*ads|adwords|publicit√©.*google/g,\n    'facebook_ads': /facebook.*ads|meta.*ads|publicit√©.*facebook/g,\n    'linkedin': /linkedin|r√©seau.*professionnel/g,\n    'instagram': /instagram|insta.*marketing/g,\n    'zapier': /zapier|int√©gration.*multiple/g,\n    'airtable': /airtable|base.*donn√©es.*visual/g\n  };\n\n  Object.entries(integrationPatterns).forEach(([tool, pattern]) => {\n    if (pattern.test(text)) {\n      analysis.required_integrations.push(tool);\n      analysis.technical_requirements.apis.push(tool + '_api');\n    }\n  });\n\n  // Estimation de l'architecture sugg√©r√©e\n  if (analysis.required_integrations.length > 3) {\n    analysis.suggested_architecture.pattern = 'complex_orchestration';\n    analysis.workflow_complexity = 'high';\n  } else if (analysis.required_integrations.length > 1) {\n    analysis.suggested_architecture.pattern = 'multi_integration';\n    analysis.workflow_complexity = 'medium';\n  } else {\n    analysis.suggested_architecture.pattern = 'simple_automation';\n  }\n\n  // Composants d'architecture recommand√©s\n  const architectureComponents = {\n    'lead_generation': ['data_collector', 'qualifier', 'enricher', 'crm_integrator'],\n    'customer_support': ['ticket_classifier', 'auto_responder', 'escalation_manager'],\n    'content_creation': ['content_generator', 'editor', 'publisher', 'scheduler'],\n    'data_processing': ['data_validator', 'transformer', 'analyzer', 'reporter'],\n    'marketing_automation': ['campaign_manager', 'segment_manager', 'performance_tracker'],\n    'sales_automation': ['lead_scorer', 'pipeline_manager', 'follow_up_scheduler']\n  };\n\n  analysis.suggested_architecture.components = \n    architectureComponents[primaryPurpose] || ['processor', 'validator', 'notifier'];\n\n  return analysis;\n}\n\n// G√©n√©ration des sp√©cifications techniques\nfunction generateTechnicalSpecs(analysis) {\n  return {\n    estimated_nodes: Math.min(20, analysis.suggested_architecture.components.length * 2 + analysis.required_integrations.length + 3),\n    estimated_development_time: {\n      simple: '30-60 minutes',\n      medium: '1-2 hours', \n      high: '2-4 hours'\n    }[analysis.workflow_complexity],\n    required_credentials: analysis.required_integrations.map(tool => `${tool}_credentials`),\n    testing_strategy: {\n      unit_tests: analysis.workflow_complexity !== 'simple',\n      integration_tests: analysis.required_integrations.length > 1,\n      shadow_testing: true,\n      performance_testing: analysis.workflow_complexity === 'high'\n    }\n  };\n}\n\nlet briefAnalysis;\nif (context.request_type === 'agent_audit_cycle') {\n  // Mode audit - analyse des agents existants\n  briefAnalysis = {\n    audit_scope: 'all_agents',\n    analysis_type: 'performance_review',\n    agent_purpose: { primary: 'system_audit', confidence: 1.0 },\n    required_integrations: ['monitoring_tools'],\n    workflow_complexity: 'medium'\n  };\n} else {\n  // Mode cr√©ation d'agent\n  briefAnalysis = analyzeBrief(payload.agent_brief, payload.agent_specifications);\n}\n\nconst technicalSpecs = generateTechnicalSpecs(briefAnalysis);\n\n// S√©lection du LLM optimal pour cette t√¢che\nconst llmSelection = {\n  recommended_llm: briefAnalysis.workflow_complexity === 'high' ? 'claude-3-5-sonnet' :\n                   briefAnalysis.agent_purpose.primary.includes('content') ? 'gpt-4-turbo' :\n                   briefAnalysis.agent_purpose.primary.includes('data') ? 'deepseek-coder' :\n                   'ollama-llama3.1',\n  reasoning: `S√©lectionn√© pour ${briefAnalysis.agent_purpose.primary} avec complexit√© ${briefAnalysis.workflow_complexity}`,\n  fallback_options: ['gpt-4-turbo', 'claude-3-5-sonnet', 'ollama-llama3.1']\n};\n\nreturn {\n  ...$json,\n  brief_analysis: briefAnalysis,\n  technical_specifications: technicalSpecs,\n  llm_recommendation: llmSelection,\n  forgemaster_assessment: {\n    feasibility: briefAnalysis.agent_purpose.confidence > 0.6 ? 'high' : 'medium',\n    estimated_success_rate: Math.round(briefAnalysis.agent_purpose.confidence * 100),\n    development_confidence: briefAnalysis.workflow_complexity === 'simple' ? 0.95 : \n                           briefAnalysis.workflow_complexity === 'medium' ? 0.85 : 0.75\n  },\n  analysis_timestamp: new Date().toISOString(),\n  next_stage: 'llm_generation'\n};"
      },
      "id": "brief-analysis-engine-005",
      "name": "üî¨ Brief Analysis Engine",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [640, 600]
    },
    {
      "parameters": {
        "dataType": "string",
        "value1": "={{ $json.llm_recommendation.recommended_llm }}",
        "rules": {
          "rules": [
            {
              "value2": "claude-3-5-sonnet",
              "output": 0
            },
            {
              "value2": "gpt-4-turbo",
              "output": 1
            },
            {
              "value2": "deepseek-coder",
              "output": 2
            },
            {
              "value2": "ollama-llama3.1",
              "output": 3
            }
          ]
        },
        "fallbackOutput": 3
      },
      "id": "llm-agent-switch-006",
      "name": "üé≠ Agent Generation LLM Switch",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 1,
      "position": [860, 600]
    },
    {
      "parameters": {
        "model": "claude-3-5-sonnet-20241022",
        "options": {
          "temperature": 0.2,
          "maxTokens": 8000
        },
        "messages": {
          "values": [
            {
              "content": "Tu es ConstructorCore, Architecte IA Elite de Nova-ForgeMaster V3.1. Ta mission: g√©n√©rer un agent IA parfaitement fonctionnel.\n\n### CONSTITUTIONAL PROTOCOLS ###\nOutils Autoris√©s: {{ $json.context.constitutional_compliance.rules_applied.join(', ') }}\nValidation: {{ $json.context.constitutional_compliance.validation_passed ? 'PASSED' : 'FAILED' }}\n\n### MISSION BRIEF ###\nDemande: {{ $json.payload.agent_brief }}\nObjectif Principal: {{ $json.brief_analysis.agent_purpose.primary }}\nComplexit√©: {{ $json.brief_analysis.workflow_complexity }}\nInt√©grations: {{ $json.brief_analysis.required_integrations.join(', ') }}\nArchitecture: {{ $json.brief_analysis.suggested_architecture.pattern }}\n\n### TECHNICAL SPECIFICATIONS ###\nN≈ìuds Estim√©s: {{ $json.technical_specifications.estimated_nodes }}\nTemps Dev: {{ $json.technical_specifications.estimated_development_time }}\nCredentials: {{ $json.technical_specifications.required_credentials.join(', ') }}\n\n### THINKING PROCESS ###\nAnalyse d'abord:\n1. D√©construction de la mission et identification des objectifs\n2. S√©lection et validation des outils (Constitutional Check)\n3. S√©quen√ßage du workflow avec gestion d'erreurs\n4. Architecture n8n optimale\n\n### OUTPUT FORMAT ###\nR√©ponds UNIQUEMENT avec ce JSON:\n```json\n{\n  \"agent_name\": \"string\",\n  \"agent_mission\": \"string\",\n  \"version\": \"1.0\",\n  \"status\": \"pending_sandbox_test\",\n  \"thinking_process\": \"string\",\n  \"complexity_analysis\": {\n    \"level\": \"{{ $json.brief_analysis.workflow_complexity }}\",\n    \"confidence\": {{ $json.brief_analysis.agent_purpose.confidence }},\n    \"success_probability\": {{ $json.forgemaster_assessment.development_confidence }}\n  },\n  \"n8n_workflow\": {\n    \"name\": \"string\",\n    \"description\": \"string\",\n    \"nodes\": [\n      {\n        \"parameters\": {\n          \"__node_name\": \"string (nom explicite)\",\n          \"__node_documentation\": \"string (R√¥le, Entr√©es, Sorties, Erreurs)\"\n        },\n        \"name\": \"string\",\n        \"type\": \"string\",\n        \"position\": [100, 100],\n        \"id\": \"string\"\n      }\n    ],\n    \"connections\": {},\n    \"settings\": {\n      \"executionOrder\": \"v1\"\n    }\n  },\n  \"dependencies\": [],\n  \"estimated_performance\": {\n    \"throughput\": \"string\",\n    \"latency\": \"string\",\n    \"reliability\": \"string\"\n  }\n}\n```",
              "type": "text"
            }
          ]
        }
      },
      "id": "claude-agent-generator-007",
      "name": "üß† Claude Agent Architect",
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1,
      "position": [1080, 400],
      "credentials": {
        "anthropicApi": {
          "id": "anthropic-forgemaster-key",
          "name": "VOTRE_CLE_ANTHROPIC_ICI"
        }
      }
    },
    {
      "parameters": {
        "url": "https://api.openai.com/v1/chat/completions",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "requestMethod": "POST",
        "jsonParameters": true,
        "parametersJson": "{\n  \"model\": \"gpt-4-turbo\",\n  \"messages\": [\n    {\n      \"role\": \"system\",\n      \"content\": \"Tu es ConstructorCore, Architecte IA Elite de Nova-ForgeMaster. Expert en cr√©ation d'agents pour business et marketing automation.\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"NOVA-FORGEMASTER AGENT CREATION:\\n\\nBRIEF CLIENT: {{ $json.payload.agent_brief }}\\nOBJECTIF: {{ $json.brief_analysis.agent_purpose.primary }}\\nCOMPLEXIT√â: {{ $json.brief_analysis.workflow_complexity }}\\nINT√âGRATIONS: {{ $json.brief_analysis.required_integrations.join(', ') }}\\n\\nCr√©e un agent n8n avec workflow JSON complet.\\n\\nFormat de r√©ponse JSON requis:\\n{\\n  \\\"agent_name\\\": \\\"nom_agent\\\",\\n  \\\"agent_mission\\\": \\\"description_mission\\\",\\n  \\\"version\\\": \\\"1.0\\\",\\n  \\\"thinking_process\\\": \\\"analyse_complete\\\",\\n  \\\"n8n_workflow\\\": {\\n    \\\"name\\\": \\\"workflow_name\\\",\\n    \\\"nodes\\\": [n≈ìuds_n8n_complets],\\n    \\\"connections\\\": {}\\n  },\\n  \\\"estimated_performance\\\": {\\n    \\\"throughput\\\": \\\"estimation\\\",\\n    \\\"reliability\\\": \\\"pourcentage\\\"\\n  }\\n}\"\n    }\n  ],\n  \"temperature\": 0.3,\n  \"max_tokens\": 8000\n}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer VOTRE_CLE_OPENAI_ICI"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        }
      },
      "id": "gpt4-agent-generator-008",
      "name": "üöÄ GPT-4 Agent Creator",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [1080, 500]
    },
    {
      "parameters": {
        "url": "https://api.deepseek.com/v1/chat/completions",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "requestMethod": "POST",
        "jsonParameters": true,
        "parametersJson": "{\n  \"model\": \"deepseek-coder\",\n  \"messages\": [\n    {\n      \"role\": \"system\",\n      \"content\": \"Tu es ConstructorCore, Architecte technique de Nova-ForgeMaster. Expert en agents d'automatisation technique et int√©gration d'APIs.\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"CR√âATION AGENT TECHNIQUE:\\n\\nSP√âCIFICATIONS: {{ $json.payload.agent_brief }}\\nTYPE: {{ $json.brief_analysis.agent_purpose.primary }}\\nARCHITECTURE: {{ $json.brief_analysis.suggested_architecture.pattern }}\\nAPIs: {{ $json.brief_analysis.required_integrations.join(', ') }}\\nN≈íUDS ESTIM√âS: {{ $json.technical_specifications.estimated_nodes }}\\n\\nG√©n√®re agent n8n avec workflow technique optimis√©.\\n\\nJSON attendu:\\n{\\n  \\\"agent_name\\\": \\\"nom_technique\\\",\\n  \\\"agent_mission\\\": \\\"mission_technique\\\",\\n  \\\"version\\\": \\\"1.0\\\",\\n  \\\"technical_architecture\\\": {\\n    \\\"pattern\\\": \\\"architecture_type\\\",\\n    \\\"components\\\": [\\\"composants\\\"]\\n  },\\n  \\\"n8n_workflow\\\": {\\n    \\\"name\\\": \\\"workflow_name\\\",\\n    \\\"nodes\\\": [n≈ìuds_techniques_d√©taill√©s],\\n    \\\"connections\\\": {},\\n    \\\"error_handling\\\": \\\"strat√©gie_erreurs\\\"\\n  },\\n  \\\"api_integrations\\\": [\\\"liste_apis\\\"],\\n  \\\"performance_optimizations\\\": [\\\"optimisations\\\"]\\n}\"\n    }\n  ],\n  \"temperature\": 0.1,\n  \"max_tokens\": 8000\n}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer VOTRE_CLE_DEEPSEEK_ICI"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        }
      },
      "id": "deepseek-tech-generator-009",
      "name": "‚öôÔ∏è DeepSeek Technical Generator",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [1080, 600]
    },
    {
      "parameters": {
        "url": "http://localhost:11434/api/chat",
        "requestMethod": "POST",
        "jsonParameters": true,
        "parametersJson": "{\n  \"model\": \"llama3.1:8b\",\n  \"messages\": [\n    {\n      \"role\": \"system\",\n      \"content\": \"Tu es ConstructorCore de Nova-ForgeMaster. Expert en agents d'automatisation simple et efficace, optimis√©s pour la performance.\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"AGENT CREATION MISSION:\\n\\nDEMANDE: {{ $json.payload.agent_brief }}\\nBUT: {{ $json.brief_analysis.agent_purpose.primary }}\\nNIVEAU: {{ $json.brief_analysis.workflow_complexity }}\\nCOMPOSANTS: {{ $json.brief_analysis.suggested_architecture.components.join(', ') }}\\n\\nCr√©e agent n8n simple et performant.\\n\\nStructure JSON:\\n{\\n  \\\"agent_name\\\": \\\"nom_simple\\\",\\n  \\\"agent_mission\\\": \\\"mission_claire\\\",\\n  \\\"version\\\": \\\"1.0\\\",\\n  \\\"simplicity_focus\\\": \\\"approche_minimaliste\\\",\\n  \\\"n8n_workflow\\\": {\\n    \\\"name\\\": \\\"workflow_simple\\\",\\n    \\\"nodes\\\": [n≈ìuds_essentiels_seulement],\\n    \\\"connections\\\": {}\\n  },\\n  \\\"efficiency_metrics\\\": {\\n    \\\"minimal_nodes\\\": \\\"count\\\",\\n    \\\"fast_execution\\\": \\\"time_estimate\\\"\\n  }\\n}\"\n    }\n  ],\n  \"stream\": false,\n  \"options\": {\n    \"temperature\": 0.4,\n    \"top_p\": 0.9\n  }\n}"
      },
      "id": "ollama-simple-generator-010",
      "name": "ü¶ô Ollama Simple Generator",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [1080, 700]
    },
    {
      "parameters": {
        "functionCode": "// Agent JSON Parser & Validator - Nova-ForgeMaster\nconst input = $input.first().json;\nconst { context, brief_analysis, llm_recommendation } = $json;\n\nlet agentDefinition, llmResponse;\n\ntry {\n  // Parse selon le LLM utilis√©\n  if (llm_recommendation.recommended_llm === 'claude-3-5-sonnet') {\n    llmResponse = input.content || input.text;\n  } else if (llm_recommendation.recommended_llm === 'gpt-4-turbo') {\n    llmResponse = input.choices?.[0]?.message?.content || input.response;\n  } else if (llm_recommendation.recommended_llm === 'deepseek-coder') {\n    llmResponse = input.choices?.[0]?.message?.content || input.response;\n  } else if (llm_recommendation.recommended_llm === 'ollama-llama3.1') {\n    llmResponse = input.message?.content || input.response;\n  }\n\n  // Extraction du JSON\n  const jsonMatch = llmResponse.match(/\\{[\\s\\S]*\\}/);\n  if (jsonMatch) {\n    agentDefinition = JSON.parse(jsonMatch[0]);\n  } else {\n    throw new Error('No valid JSON found in LLM response');\n  }\n\n} catch (parseError) {\n  console.error('Agent parsing error:', parseError);\n  \n  // G√©n√©ration d'un agent de fallback intelligent\n  agentDefinition = generateFallbackAgent(brief_analysis, context);\n  agentDefinition.fallback_generated = true;\n  agentDefinition.original_error =
